//=========================================================
// src/Interupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES			
#include <SI_EFM8LB1_Register_Enums.h>
#include "retargetserial.h"
#include "vars.h"

volatile int send_msg;
volatile int adc1;
volatile int adc2;
volatile int adc3;
volatile int adc4;
volatile int multiplier;

SI_SBIT(PWRC, SFR_P1, 2);                  // P1.2 PWRC
SI_SBIT(LED, SFR_P1, 0);// P1.0 LED

SI_SBIT(IDLE,PCON0,0);// set IDLE mode
SI_SBIT(SNOOZE,PCON1,7);// set SNOOZE mode

SI_SBIT (HALL, SFR_P0, 6); // port match pin

SI_INTERRUPT(INT0_ISR,INT0_IRQn)
  {

    // This will trigger on falling.
    RETARGET_PRINTF ("\nINT0 is active low now");
    //IDLE = 1;// set idle mode - will be woken up by any interrupt

    // no clear needed as it will clear when it is no longer triggering

  }

// Port Match ISR

SI_INTERRUPT(PMATCH_ISR,PMATCH_IRQn){
  RETARGET_PRINTF ("\nPort Match Interrupt fired");

}

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
// This ISR averages 2048 samples then prints the result to the terminal.  The
// ISR is called after each ADC conversion which is triggered by Timer2.
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(ADC0EOC_ISR, ADC0EOC_IRQn)
  {
    static uint32_t accumulator = 0;     // Accumulator for averaging
    static uint16_t measurements = 2048;// Measurement counter
    uint32_t result = 0;
    uint32_t mV;// Measured voltage in mV
    uint32_t uA;
    uint8_t SFRPAGE_save;

    //LED=1; // turn on the LED

    // Select a pin

    switch(send_msg)
      {
        case 0:
        ADC0MX = ADC0MX_ADC0MX__ADC0P13; // select ADC13- P1.7
        break;
        case 1:
        ADC0MX = ADC0MX_ADC0MX__ADC0P12;
        break;
        case 2:
        ADC0MX = ADC0MX_ADC0MX__ADC0P11;
        break;
        case 3:
        ADC0MX = ADC0MX_ADC0MX__ADC0P10;
        break;
        default:
        break;
      }

    accumulator += ADC0;
    measurements--;

    if(measurements == 0)
      {
        measurements = 2048;
        result = accumulator / 2048;
        accumulator = 0;

        // The 14-bit ADC value is averaged across 2048 measurements.
        // The measured voltage applied to P1.7 is then:
        //
        //                           Vref (mV)
        //   measurement (mV) =   --------------- * result (bits)
        //                       (2^14)-1 (bits)

        mV = (result * 3300) / 16383;
        R1 = 3.0;
        R2 = 5.6;
        // U4 is
#ifdef MINI
	  R1 = 1.0;
#endif

#ifdef W_VER
	  multiplier = 200;
#elif H_VER
	  multiplier = 100;
#elif F_VER
	  multiplier = 50;
#endif

        switch(send_msg)
          {
            case 0:
            uA = (uint32_t)((result * 2400) / (16383*scale) * 1000 / (multiplier*R1));
            adc1 = uA;
            break;
            case 1:
            uA = (result * 3277) / 16383 * 1000 / (200*R1);
            adc2 = uA;
#ifdef MINI
	         adc2= mV;
#endif
            break;
            case 2:
            adc3 = mV;
            break;
            case 3:
            adc4 = mV;
#ifdef MINI
	         // high voltage element 110k/10k

#endif

            break;
            default:
            break;
          }
        send_msg++; // increment count

        SFRPAGE_save = SFRPAGE;
        SFRPAGE = LEGACY_PAGE;
        //RETARGET_PRINTF ("\nP1.7 voltage: %ld mV\n", mV);
        SFRPAGE = SFRPAGE_save;
        //LED = 0; // turn off the LED
      }

    ADC0CN0_ADINT = 0;              // Clear ADC0 conv. complete flag
  }

//-----------------------------------------------------------------------------
// PMATCH_ISR
//-----------------------------------------------------------------------------
//
// PMATCH ISR Content goes here. Remember to clear flag bits:

//
//-----------------------------------------------------------------------------
SI_INTERRUPT (PMATCH_ISR, PMATCH_IRQn)
  {

  }

