C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART_0
OBJECT MODULE PLACED IN .\src\uart_0.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Ben\Doc
                    -uments\Git\wireless_measurements\software\firmware\EFM8_SWM\src\uart_0.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNIN
                    -GLEVEL(2) FLOATFUZZY(3) OPTIMIZE(0,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Ben\Documents\Git
                    -\wireless_measurements\software\firmware\EFM8_SWM\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//kit
                    -s/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/shared/si8051
                    -Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/EFM8LB1/inc) PRINT(.\src\uart_0.lst) COND PAG
                    -EWIDTH(120) PAGELENGTH(65) OBJECT(.\src\uart_0.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "uart_0.h"
   8          
   9          #if EFM8PDL_UART0_AUTO_PAGE == 1
  10          // declare variable needed for autopage enter/exit
  11          #define DECL_PAGE uint8_t savedPage
  12          // enter autopage section
  13          #define SET_PAGE(p)     do                                                    \
  14                                  {                                                     \
  15                                    savedPage = SFRPAGE;  /* save current SFR page */   \
  16                                    SFRPAGE = (p);        /* set SFR page */            \
  17                                  } while(0)
  18          // exit autopage section
  19          #define RESTORE_PAGE    do                                                    \
  20                                  {                                                     \
  21                                    SFRPAGE = savedPage;  /* restore saved SFR page */  \
  22                                  } while(0)
  23          
  24          #else
              #define DECL_PAGE
              #define SET_PAGE
              #define RESTORE_PAGE
              #endif
  29          
  30          
  31          uint8_t UART0_getIntFlags()
  32          {
  33   1        uint8_t val;
  34   1        DECL_PAGE;
  35   1        SET_PAGE(0x00);
  36   1        val = SCON0 & (UART0_TX_IF | UART0_RX_IF);
  37   1        RESTORE_PAGE;
  38   1        return val;
  39   1      }
  40          
  41          void UART0_clearIntFlag(uint8_t flag)
  42          {
  43   1        DECL_PAGE;
  44   1        SET_PAGE(0x00);
  45   1        SCON0 &= ~(flag);
  46   1        RESTORE_PAGE;
  47   1      }
  48          
  49          void UART0_initTxPolling()
  50          {
C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 2   

  51   1        DECL_PAGE;
  52   1        SET_PAGE(0x00);
  53   1        SCON0_TI = 1;
  54   1        RESTORE_PAGE;
  55   1      }
  56          
  57          void UART0_write(uint8_t value)
  58          {
  59   1        DECL_PAGE;
  60   1        SET_PAGE(0x00);
  61   1        SBUF0 = value;
  62   1        RESTORE_PAGE;
  63   1      }
  64          
  65          uint8_t UART0_read(void)
  66          {
  67   1        uint8_t val;
  68   1        DECL_PAGE;
  69   1        SET_PAGE(0x00);
  70   1        val = SBUF0;
  71   1        RESTORE_PAGE;
  72   1        return val;
  73   1      }
  74          
  75          uint8_t UART0_read_if_available(void){
  76   1        uint8_t val;
  77   1        DECL_PAGE;
  78   1        SET_PAGE(0x00);
  79   1        if(SCON0_RI){
  80   2            SCON0_RI = 0;
  81   2            val = SBUF0;
  82   2        } else {
  83   2            val = 0;
  84   2        }
  85   1        RESTORE_PAGE;
  86   1        return val;
  87   1      }
  88          
  89          
  90          void UART0_writeWithExtraBit(uint16_t value)
  91          {
  92   1        DECL_PAGE;
  93   1        SET_PAGE(0x00);
  94   1        SCON0_TB8 = value >> 8;
  95   1        SBUF0 = value;
  96   1        RESTORE_PAGE;
  97   1      }
  98          
  99          uint16_t UART0_readWithExtraBit(void)
 100          {
 101   1        uint16_t val;
 102   1        DECL_PAGE;
 103   1        SET_PAGE(0x00);
 104   1        val = (SBUF0 | ((SCON0 & SCON0_RB8__BMASK) << 6) );
 105   1        RESTORE_PAGE;
 106   1        return val;
 107   1      }
 108          
 109          void UART0_init(UART0_RxEnable_t rxen, UART0_Width_t width, UART0_Multiproc_t mce)
 110          {
 111   1        DECL_PAGE;
 112   1        SET_PAGE(0x00);
 113   1        SCON0 &= ~(SCON0_SMODE__BMASK
C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 3   

 114   1                   | SCON0_MCE__BMASK
 115   1                   | SCON0_REN__BMASK);
 116   1        SCON0 = mce | rxen | width;
 117   1        RESTORE_PAGE;
 118   1      }
 119          
 120          void UART0_reset()
 121          {
 122   1        DECL_PAGE;
 123   1        SET_PAGE(0x00);
 124   1        SCON0 = SCON0_SMODE__8_BIT
 125   1                | SCON0_MCE__MULTI_DISABLED
 126   1                | SCON0_REN__RECEIVE_DISABLED
 127   1                | SCON0_TB8__NOT_SET
 128   1                | SCON0_RB8__NOT_SET
 129   1                | SCON0_TI__NOT_SET
 130   1                | SCON0_RI__NOT_SET;
 131   1        RESTORE_PAGE;
 132   1      }
 133          
 134          //=========================================================
 135          // Interrupt API
 136          //=========================================================
 137          #if EFM8PDL_UART0_USE_BUFFER == 1
              
              /**
               * Internal variable fort trackig buffer transfers. transferLenth[UART0_TX_TRANSFER] = bytes remaining in 
             -transfer.
               */
              SI_SEGMENT_VARIABLE(txRemaining, static uint8_t,  SI_SEG_XDATA)=0;
              SI_SEGMENT_VARIABLE(rxRemaining, static uint8_t,  SI_SEG_XDATA)=0;
              SI_SEGMENT_VARIABLE_SEGMENT_POINTER(txBuffer,    static uint8_t, EFM8PDL_UART0_TX_BUFTYPE, SI_SEG_XDATA);
              SI_SEGMENT_VARIABLE_SEGMENT_POINTER(rxBuffer,    static uint8_t, EFM8PDL_UART0_RX_BUFTYPE, SI_SEG_XDATA);
              
              
              SI_INTERRUPT(UART0_ISR, UART0_IRQn)
              {
                //Buffer and clear flags immediately so we don't miss an interrupt while processing
                uint8_t flags, discard;
                SFRPAGE = 0x00; // Rely on page stack to restore page on return from int
              
                flags = SCON0;
                UART0_clearIntFlag(UART0_TX_IF); //can't clear RX with software
              
                if (flags &  SCON0_RI__SET)
                {
                  if(rxRemaining)
                  {
                    *rxBuffer = SBUF0;
                    ++rxBuffer;
                    --rxRemaining;
                    if (!rxRemaining)
                    {
                      UART0_receiveCompleteCb();
                    }
                  }
                  else
                  {
                    discard = SBUF0; //Need to read SBUF to clear interrupt flag.
                  }
                }
              
                if ((flags & SCON0_TI__SET))
C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 4   

                {
                  if (txRemaining){
                    SBUF0 = *txBuffer;
                    ++txBuffer;
                    --txRemaining;
                  }
                  else
                  {
                    UART0_transmitCompleteCb();
                  }
                }
              }
              
              void UART0_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
                                                              uint8_t,
                                                              EFM8PDL_UART0_TX_BUFTYPE),
                                     uint8_t length)
              {
                DECL_PAGE;
                SET_PAGE(0x00);
                //Init internal data
                txBuffer = buffer+1;
                txRemaining = length-1;
              
                //Send initial byte
                SBUF0 = *buffer;
                RESTORE_PAGE;
              }
              
              void UART0_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
                                                                     uint8_t,
                                                                     EFM8PDL_UART0_RX_BUFTYPE),
                                            uint8_t length)
              {
                //Init internal data
                rxBuffer = buffer;
                rxRemaining = length;
              }
              
              void UART0_abortWrite()
              {
                txRemaining = 0;
              }
              
              void UART0_abortRead()
              {
                rxRemaining = 0;
              }
              
              uint8_t UART0_txBytesRemaining()
              {
                return txRemaining;
              }
              
              uint8_t UART0_rxBytesRemaining()
              {
                return rxRemaining;
              }
              
              #endif //EFM8PDL_UART0_USE_BUFFER
 236          
 237          #if EFM8PDL_UART0_USE_STDIO == 1
 238          
C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 5   

 239          #if defined __C51__
 240          
 241          char putchar(char c){
 242   1        DECL_PAGE;
 243   1        SET_PAGE(0x00);
 244   1        while(!SCON0_TI);
 245   1        SBUF0 = c;
 246   1        SCON0_TI = 0;
 247   1        RESTORE_PAGE;
 248   1        return c;
 249   1      }
 250          
 251          char _getkey(){
 252   1        char val;
 253   1        DECL_PAGE;
 254   1        SET_PAGE(0x00);
 255   1        while(!SCON0_RI);
 256   1        SCON0_RI = 0;
 257   1      
 258   1        val = SBUF0;
 259   1        RESTORE_PAGE;
 260   1        return val;
 261   1      }
 262          
 263          #elif defined __ICC8051__
              
              int putchar(int c){
                DECL_PAGE;
                SET_PAGE(0x00);
                while(!SCON0_TI);
                SBUF0 = c;
                SCON0_TI = 0;
                RESTORE_PAGE;
                return c;
              }
              
              int getchar(void){
                char val;
                DECL_PAGE;
                SET_PAGE(0x00);
                while(!SCON0_RI);
                SCON0_RI = 0;
              
                val = SBUF0;
                RESTORE_PAGE;
                return val;
              }
              
              #endif
 288          
 289          void UART0_initStdio()
 290          {
 291   1        DECL_PAGE;
 292   1        SET_PAGE(0x00);
 293   1        SCON0 |= SCON0_REN__RECEIVE_ENABLED | SCON0_TI__SET;
 294   1        RESTORE_PAGE;
 295   1      }
 296          #endif //EFM8PDL_UART0_USE_STDIO


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    270    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.0.0   UART_0                                                            09/27/2021 09:12:38 PAGE 6   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
