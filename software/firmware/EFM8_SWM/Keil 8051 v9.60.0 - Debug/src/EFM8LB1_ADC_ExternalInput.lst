C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EFM8LB1_ADC_EXTERNALINPUT
OBJECT MODULE PLACED IN .\src\EFM8LB1_ADC_ExternalInput.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Ben\Doc
                    -uments\Git\wireless_measurements\software\firmware\EFM8_SWM\src\EFM8LB1_ADC_ExternalInput.c OMF2 SMALL DEBUG OBJECTEXTEN
                    -D ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(0,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\User
                    -s\Ben\Documents\Git\wireless_measurements\software\firmware\EFM8_SWM\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sd
                    -ks/8051/v4.2.1//kits/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//D
                    -evice/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/EFM8LB1/inc) PRINT(.\src\E
                    -FM8LB1_ADC_ExternalInput.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\EFM8LB1_ADC_ExternalInput.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // EFM8LB1_ADC_ExternalInput.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014 Silicon Laboratories, Inc.
   5          // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   6          //
   7          // Program Description:
   8          //
   9          // This example code takes and averages 2048 analog measurements from input
  10          // P1.7 using ADC0, then prints the results to a terminal window via the UART.
  11          //
  12          // The system is clocked by the internal 24.5 MHz oscillator divided by 1.
  13          // Timer 2 triggers a conversion on ADC0 on each overflow.  The completion of
  14          // this conversion in turn triggers an interrupt service routine (ISR).  The ISR
  15          // averages 2048 measurements, then prints the value to the terminal via printf
  16          // before starting another average cycle.
  17          //
  18          // The analog multiplexer selects P1.7 as the positive ADC0 input. This pin is
  19          // configured as an analog input in the port initialization routine. The
  20          // negative ADC0 input is connected via mux to ground, which provides for a
  21          // single-ended ADC input.
  22          //
  23          // An analog joystick is connected to P1.7. Each joystick position corresponds
  24          // to a unique voltage.
  25          //
  26          // Terminal output is done via printf, which directs the characters to
  27          // UART0.  A UART initialization routine is therefore necessary.
  28          //
  29          // ADC Settling Time Requirements, Sampling Rate:
  30          // ----------------------------------------------
  31          //
  32          // The total sample time per input is comprised of an input setting time
  33          // (Tsettle), followed by a conversion time (Tconvert):
  34          //
  35          // Tsample  = Tsettle + Tconvert
  36          //
  37          // |--------Settling-------|==Conversion==|----Settling--- . . .
  38          // Timer 2 overflow        ^
  39          // ADC0 ISR                               ^
  40          //
  41          // The ADC input voltage must be allowed adequate time to settle before the
  42          // conversion is made.  This settling depends on the external source
  43          // impedance, internal mux impedance, and internal capacitance.
  44          // Settling time is given by:
  45          //
  46          //                   | 2^n |
  47          //    Tsettle =   ln | --- | * Rtotal * Csample
  48          //                   | SA  |
  49          //
  50          // For example, assume Rtotal = 100 kohm. The expression evaluates to:
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 2   

  51          //
  52          //                   | 2^14 |
  53          //    Tsettle =   ln | ---- | * 105e3 * 5e-12 = 5.82 us
  54          //                   | 0.25 |
  55          //
  56          // In addition, one must allow at least 1.5uS after changing analog mux
  57          // inputs or PGA settings.  The settling time in this example, then, is
  58          // dictated by the large external source resistance.
  59          //
  60          // The conversion time is given in the datasheet (14-bit mode, SAR clock 18 MHz)
  61          // as 0.81 us.
  62          //
  63          // Tsample, minimum  = Tsettle + Tconvert
  64          //                   = 5.82 us + 0.81 us
  65          //                   = 6.63 us
  66          //
  67          // Timer2 is set to start a conversion every 100 us, which is far longer
  68          // than the minimum required.
  69          //
  70          // Resources:
  71          //   SYSCLK - 24.5 MHz HFOSC0 / 1
  72          //   ADC    - 14-bit, VREF = VDD (3.3V)
  73          //   UART0  - 115200 baud, 8-N-1
  74          //   Timer1 - UART0 clock source
  75          //   Timer2 - ADC start of conversion source
  76          //   P0.4   - UART0 TX
  77          //   P0.5   - UART0 RX
  78          //   P2.2   - Board Controller enable
  79          //   P3.4   - Display enable
  80          //
  81          //-----------------------------------------------------------------------------
  82          // How To Test: EFM8LB1 STK
  83          //-----------------------------------------------------------------------------
  84          // 1) Place the switch in "AEM" mode.
  85          // 2) Connect the EFM8LB1 STK board to a PC using a mini USB cable.
  86          // 3) Compile and download code to the EFM8LB1 STK board.
  87          //    In Simplicity Studio IDE, select Run -> Debug from the menu bar,
  88          //    click the Debug button in the quick menu, or press F11.
  89          // 4) On the PC, open HyperTerminal (or any other terminal program) and connect
  90          //    to the JLink CDC UART Port at 115200 baud rate and 8-N-1.
  91          // 5) Run the code.
  92          //    In Simplicity Studio IDE, select Run -> Resume from the menu bar,
  93          //    click the Resume button in the quick menu, or press F8.
  94          // 6) Move the joystick. The terminal program will print the voltage for
  95          //    each joystick position.
  96          //
  97          // Target:         EFM8LB1
  98          // Tool chain:     Generic
  99          //
 100          // Release 0.1 (ST)
 101          //    - Initial Revision
 102          //    - 06 MAR 2015
 103          //
 104          
 105          //-----------------------------------------------------------------------------
 106          // Includes
 107          //-----------------------------------------------------------------------------
 108          #include <SI_EFM8LB1_Register_Enums.h>
 109          //#include <stdint.h>
 110          #include <stdio.h>
 111          #include "InitDevice.h"
 112          //#include "retargetserial.h"
 113          #include "vars.h"
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 3   

 114          #include "uart_0.h"
 115          
 116          //-----------------------------------------------------------------------------
 117          // Pin Definitions
 118          //-----------------------------------------------------------------------------
 119          SI_SBIT (DISP_EN, SFR_P3, 4);          // Display Enable
 120          #define DISP_BC_DRIVEN   0             // 0 = Board Controller drives display
 121          #define DISP_EFM8_DRIVEN 1             // 1 = EFM8 drives display
 122          
 123          SI_SBIT (BC_EN, SFR_P2, 2);            // Board Controller Enable
 124          #define BC_DISCONNECTED 0              // 0 = Board Controller disconnected
 125                                                 //     to EFM8 UART pins
 126          #define BC_CONNECTED    1              // 1 = Board Controller connected
 127                                                 //     to EFM8 UART pins
 128          
 129          
 130          SI_SBIT(PWRC, SFR_P1, 2);                  // P1.2 PWRC
 131          SI_SBIT(LED, SFR_P1, 0);                  // P1.0 LED
 132          SI_SBIT(HALL, SFR_P0,6);
 133          
 134          
 135          //SI_SEGMENT_VARIABLE(scale, float, SI_SEG_XDATA);
 136          uint8_t scale;
 137          
 138          const uint32_t xdata UUID _at_ 0xFFC3;
 139          //uint8_t id;
 140          
 141          void _delay_ms(uint32_t ms);
 142          void _flash_LED();
 143          //-----------------------------------------------------------------------------
 144          // SiLabs_Startup() Routine
 145          // ----------------------------------------------------------------------------
 146          // This function is called immediately after reset, before the initialization
 147          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 148          // useful place to disable the watchdog timer, which is enable by default
 149          // and may trigger before main() in some instances.
 150          //-----------------------------------------------------------------------------
 151          void SiLabs_Startup (void)
 152          {
 153   1        // Disable the watchdog here
 154   1        //id = UUID;
 155   1        //id=id&0xFF;
 156   1        //id = UUID & 0xFF;
 157   1      
 158   1      
 159   1      }
 160          #define F_CPU 24500000
 161          #define CPU_DIV 1
 162          #define SYSCLK_MS  ((F_CPU / CPU_DIV) / 1000.0) / 60.0 // Convert to oscillations per ms
 163          #define SYSCLK_US  ((F_CPU / CPU_DIV) / 1000000.0) // Convert to oscillations per us
 164          #define SUBTRACT_MS 7500.0 / 60.0 / CPU_DIV
 165          
 166          void _delay_ms(uint32_t ms){
 167   1       // Subtract n clock cycles for every ms to account for the time that the loop takes
 168   1       uint32_t clockCycles = SYSCLK_MS * ms;
 169   1       uint32_t substract = (SUBTRACT_MS * ms) + 34;
 170   1      
 171   1       if(clockCycles > substract) clockCycles -= substract;
 172   1      
 173   1       while(clockCycles-- > 0){
 174   2        _nop_();
 175   2       }
 176   1      }
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 4   

 177          
 178          
 179          /*
 180           * This function sets up the Bluetooth module
 181           * App Mode
 182           */
 183          
 184          void init_device(void) {
 185   1      
 186   1        //uint32_t someval;
 187   1        //uint8_t your_id;
 188   1        LED = 1;
 189   1        PWRC = 0; // set AT mode
 190   1        //someval = UUID; // get th UUID
 191   1      
 192   1        //your_id = (uint8_t)(UUID & 0xFF); // take only 128 bits of the ID
 193   1      
 194   1        _delay_ms(50); // wait for module to respond
 195   1      
 196   1        //RETARGET_PRINTF("AT+NAMESWM-%d",(int)your_id); // set the name of the device
 197   1      
 198   1        printf("AT+NAMESWM-%d",(int)(uint8_t)(UUID & 0xFF));
 199   1      
 200   1        _delay_ms(30); // wait for module to respond
 201   1        LED = 0; // ok
 202   1        PWRC = 1; // unset AT mode
 203   1      
 204   1        // determine the scale and set accordingly
 205   1      
 206   1        switch(ADC0CN0 & ADC0CN0_ADGN__FMASK) {
 207   2          case ADC0CN0_ADGN__GAIN_0P75:
 208   2            scale = 75;
 209   2            break;
 210   2          case ADC0CN0_ADGN__GAIN_0P5:
 211   2            scale = 50;
 212   2            break;
 213   2          case ADC0CN0_ADGN__GAIN_0P25:
 214   2            scale = 25;
 215   2            break;
 216   2          default:
 217   2            scale = 100;
 218   2      
 219   2        }
 220   1      }
 221          /*
 222          void set_device_AT() {
 223          
 224            // RETARGET_PRINTF("AT+HOSTEN");
 225          
 226            //inputcharacter = getchar();
 227            PWRC = 0; // set AT mode
 228          
 229            RETARGET_PRINTF("AT+NAMESWM-%d",500);
 230          
 231            PWRC = 1; // unset AT mode
 232          
 233          
 234          }
 235          */
 236          
 237          
 238          void sleep_device() {
 239   1        LED = 1;
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 5   

 240   1        PWRC = 0; // set AT mode
 241   1        //RETARGET_PRINTF("AT+SLEEP2"); // send the BLE module into deep sleep
 242   1        printf("AT+SLEEP2");
 243   1        _delay_ms(30); // wait for command to be received and for the device to respond
 244   1        PWRC = 1; // unset AT mode
 245   1        LED = 0;
 246   1        PCON1 |= 0x80; // set to SNOOZE - will only be woke by Timer 4
 247   1      
 248   1      }
 249          
 250          void _flash_LED(){
 251   1        LED=1;
 252   1        _delay_ms(LED_DELAY);
 253   1        LED=0;
 254   1        _delay_ms(LED_DELAY);
 255   1        LED=1;
 256   1        _delay_ms(LED_DELAY);
 257   1        LED=0;
 258   1        _delay_ms(LED_DELAY);
 259   1          LED=1;
 260   1          _delay_ms(LED_DELAY);
 261   1          LED=0;
 262   1      
 263   1      }
 264          
 265          
 266          //-----------------------------------------------------------------------------
 267          // Main Routine
 268          //-----------------------------------------------------------------------------
 269          void main (void)
 270          {
 271   1      
 272   1        uint8_t read_msg;
 273   1        bool sleep_flag = false;
 274   1      
 275   1         enter_DefaultMode_from_RESET();
 276   1         UART0_initStdio();
 277   1      
 278   1         DISP_EN = DISP_BC_DRIVEN;           // Display not driven by EFM8
 279   1      
 280   1         BC_EN = BC_CONNECTED;               // Board controller connected to EFM8
 281   1                                             // UART pins
 282   1      
 283   1         SCON0_TI = 1;                       // This STDIO library requires TI to
 284   1                                             // be set for prints to occur
 285   1      
 286   1         IE_EA = 1;                          // Enable global interrupts
 287   1         init_device(); // init device before we start ADC sampling
 288   1         //set_device_chars();
 289   1      
 290   1         while (1) {
 291   2             //if (HALL==1) {
 292   2             //    EIE1 |= 0x02; // Enable Portmatch interrupt if HALL is high (released)
 293   2                               // And do a bitwise OR operation to set a bit
 294   2             //}
 295   2             //_delay_ms(2000);
 296   2             //PCON0 |= 0x01; // set to IDLE
 297   2             //PCON1 |= 0x80; // set to SNOOZE
 298   2      
 299   2             /*
 300   2             if (LED_state==0){
 301   2                            LED = 1;
 302   2                            LED_state = 1;
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 6   

 303   2                        } else {
 304   2                            LED = 0;
 305   2                            LED_state = 0;
 306   2                        }
 307   2             _delay_ms(500);
 308   2      */
 309   2             read_msg = UART0_read_if_available(); // read UART0 message
 310   2             if (read_msg != 0) {
 311   3                 // process it
 312   3                 printf(&read_msg); // okay
 313   3                 switch (read_msg) {
 314   4      
 315   4                   case '1':
 316   4                     //printf("1 rx");
 317   4                     // set the high byte and low byte 66534
 318   4                     //
 319   4                     _flash_LED(); //indicate message received
 320   4                     // set to 2 sec wake
 321   4                     TMR4RLH = (0xFF << TMR4RLH_TMR4RLH__SHIFT);
 322   4                     TMR4RLL = (0xFE << TMR4RLL_TMR4RLL__SHIFT);
 323   4                     sleep_flag = true;
 324   4      
 325   4                     break;
 326   4                   case '2':
 327   4                     //printf("2 rx");
 328   4                     break;
 329   4                   default:
 330   4                     //printf("other rx");
 331   4                     sleep_flag = false;
 332   4                     break;
 333   4                 }
 334   3             } else {
 335   3                 // do whatever we have been doing
 336   3                 if (sleep_flag) {
 337   4      
 338   4                     sleep_device();
 339   4                     PWRC = 0; // turn on the BLE module
 340   4                     _delay_ms(50); // wait for power on
 341   4                 }
 342   3             }
 343   2             while(send_msg!=4); // blocking
 344   2      
 345   2             if (send_msg==4) {
 346   3                 LED = ~LED; // flip the bit
 347   3      
 348   3                 send_msg = 0;
 349   3      
 350   3                 //SFRPAGE_save = SFRPAGE;
 351   3                 //SFRPAGE = LEGACY_PAGE;
 352   3                 //RETARGET_PRINTF ("%d,%d,%d,%d",adc1,adc2,adc3,adc4);
 353   3      
 354   3                 printf("%u,%u,%u,%u",(uint32_t)adc1,(uint32_t)adc2,(uint32_t)adc3,(uint32_t)adc4);
 355   3      
 356   3                 //SFRPAGE = SFRPAGE_save;
 357   3      
 358   3             }
 359   2      
 360   2         }
 361   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    570    ----
C51 COMPILER V9.60.0.0   EFM8LB1_ADC_EXTERNALINPUT                                         09/24/2021 23:37:42 PAGE 7   

   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
