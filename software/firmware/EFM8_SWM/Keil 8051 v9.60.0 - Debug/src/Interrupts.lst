C51 COMPILER V9.60.0.0   INTERRUPTS                                                        09/23/2021 14:52:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Ben\Doc
                    -uments\Git\wireless_measurements\software\firmware\EFM8_SWM\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WA
                    -RNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(0,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Ben\Documents
                    -\Git\wireless_measurements\software\firmware\EFM8_SWM\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1/
                    -/kits/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/shared/si
                    -8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/EFM8LB1/inc) PRINT(.\src\Interrupts.lst) 
                    -COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES                        
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "retargetserial.h"
  12          #include "vars.h"
  13          
  14          volatile int send_msg;
  15          volatile int adc1;
  16          volatile int adc2;
  17          volatile int adc3;
  18          volatile int adc4;
  19          int multiplier;
  20          
  21          SI_SBIT(PWRC, SFR_P1, 2);                  // P1.2 PWRC
  22          SI_SBIT(LED, SFR_P1, 0);// P1.0 LED
  23          
  24          //SI_SBIT(IDLE,PCON0,0);// set IDLE mode
  25          //SI_SBIT(SNOOZE,PCON1,7);// set SNOOZE mode
  26          
  27          SI_SBIT (HALL, SFR_P0, 6);// port match pin
  28          
  29          //-----------------------------------------------------------------------------
  30          // ADC0EOC_ISR
  31          //-----------------------------------------------------------------------------
  32          //
  33          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
  34          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
  35          //
  36          // This ISR averages 2048 samples then prints the result to the terminal.  The
  37          // ISR is called after each ADC conversion which is triggered by Timer2.
  38          //
  39          //-----------------------------------------------------------------------------
  40          SI_INTERRUPT(ADC0EOC_ISR, ADC0EOC_IRQn)
  41            {
  42   1          static uint32_t accumulator = 0;     // Accumulator for averaging
  43   1          static uint16_t measurements = 2048;// Measurement counter
  44   1          uint32_t result = 0;
  45   1          uint32_t mV;// Measured voltage in mV
  46   1          uint32_t uA;
  47   1          int R1;
  48   1          int R2;
  49   1          //uint8_t SFRPAGE_save;
  50   1      
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        09/23/2021 14:52:06 PAGE 2   

  51   1          //LED=1; // turn on the LED
  52   1      
  53   1          // Select a pin
  54   1      
  55   1          switch(send_msg)
  56   1            {
  57   2              case 0:
  58   2              ADC0MX = ADC0MX_ADC0MX__ADC0P13; // select ADC13- P1.7
  59   2              break;
  60   2              case 1:
  61   2              ADC0MX = ADC0MX_ADC0MX__ADC0P12;
  62   2              break;
  63   2              case 2:
  64   2              ADC0MX = ADC0MX_ADC0MX__ADC0P11;
  65   2              break;
  66   2              case 3:
  67   2              ADC0MX = ADC0MX_ADC0MX__ADC0P10;
  68   2              break;
  69   2              default:
  70   2              break;
  71   2            }
  72   1      
  73   1          accumulator += ADC0;
  74   1          measurements--;
  75   1      
  76   1          if(measurements == 0)
  77   1            {
  78   2              measurements = 2048;
  79   2              result = accumulator / 2048;
  80   2              accumulator = 0;
  81   2      
  82   2              // The 14-bit ADC value is averaged across 2048 measurements.
  83   2              // The measured voltage applied to P1.7 is then:
  84   2              //
  85   2              //                           Vref (mV)
  86   2              //   measurement (mV) =   --------------- * result (bits)
  87   2              //                       (2^14)-1 (bits)
  88   2      
  89   2              mV = (result * 3300) / 16383;
  90   2              R1 = 30;
  91   2              R2 = 56;
  92   2              // U4 is
  93   2      #ifdef MINI
  94   2                R1 = 10;
  95   2      #endif
  96   2      
  97   2      #ifdef W_VER
  98   2                multiplier = 200;
  99   2      #elif H_VER
                        multiplier = 100;
              #elif F_VER
                        multiplier = 50;
              #endif
 104   2      
 105   2              switch(send_msg)
 106   2                {
 107   3                  case 0:
 108   3                  uA = (uint32_t)((result * 2400) / (16383*scale/100) * 1000 / (multiplier*R1/10));
 109   3                  adc1 = uA;
 110   3                  break;
 111   3                  case 1:
 112   3                  uA = (result * 3277) / 16383 * 1000 / (200*R1/10);
 113   3                  adc2 = uA;
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        09/23/2021 14:52:06 PAGE 3   

 114   3      #ifdef MINI
 115   3                       adc2= mV;
 116   3      #endif
 117   3                  break;
 118   3                  case 2:
 119   3                  adc3 = mV;
 120   3                  break;
 121   3                  case 3:
 122   3                  adc4 = mV;
 123   3      #ifdef MINI
 124   3                       // high voltage element 110k/10k
 125   3      
 126   3      #endif
 127   3      
 128   3                  break;
 129   3                  default:
 130   3                  break;
 131   3                }
 132   2              send_msg++; // increment count
 133   2      
 134   2              //SFRPAGE_save = SFRPAGE;
 135   2              //SFRPAGE = LEGACY_PAGE;
 136   2              //RETARGET_PRINTF ("\nP1.7 voltage: %ld mV\n", mV);
 137   2              //SFRPAGE = SFRPAGE_save;
 138   2              //LED = 0; // turn off the LED
 139   2            }
 140   1      
 141   1          ADC0CN0_ADINT = 0;              // Clear ADC0 conv. complete flag
 142   1        }
 143          
 144          //-----------------------------------------------------------------------------
 145          // PMATCH_ISR
 146          //-----------------------------------------------------------------------------
 147          //
 148          // PMATCH ISR Content goes here. Remember to clear flag bits:
 149          
 150          //
 151          //-----------------------------------------------------------------------------
 152          
 153           SI_INTERRUPT (PMATCH_ISR, PMATCH_IRQn)
 154           {
 155   1       //RETARGET_PRINTF ("\nPort Match Interrupt fired");
 156   1       // TODO: check if it is the pin we care about
 157   1         if (false){
 158   2         PWRC = 0; // wake BLE module
 159   2         SFRPAGE = LEGACY_PAGE;
 160   2         //EIE1 &= ~0x02; // disable Port Match interrupt
 161   2         }
 162   1       EIE1 &= ~0x02; // disable Port Match interrupt
 163   1       }
 164          
*** WARNING C294 IN LINE 158 OF C:\Users\Ben\Documents\Git\wireless_measurements\software\firmware\EFM8_SWM\src\Interrup
             -ts.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    588    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        09/23/2021 14:52:06 PAGE 4   

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
